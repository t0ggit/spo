#!/bin/bash


# Проверка количества аргументов
if [ $# != 1 ]; then
    echo "Error: It is required to provide one string argument. Provided: $#." >&2
    exit 1
fi

# Записываем слова из строки в массив
read -r -a words <<< $1
# -r чтобы отключить escape character '\'
# -a чтобы считывать пословно в массив (со стандартным разделителем

# Проходимся по массиву слов и на каждом шаге проверяем соответствие двух соседних слов правилу
for (( i = 0; i < ${#words[@]} - 1; i++ )); do
    # i - индекс левого слова из пары сравниваемых
#    echo -n "$(( i % 2 ))  ${words[i]}(${#words[i]})  ${words[i+1]}(${#words[i+1]}) : "
    if [ $(( $i % 2 )) == 0 ]; then
        # Случай, когда левое слово должно быть меньше
        if [ ${#words[i]} -gt ${#words[i+1]} ]; then
            # Меняем местами эти два слова
            buff_word=${words[i]}
            words[$i]=${words[i+1]}
            words[$i+1]=$buff_word
            unset buff_word
#            echo -n "Swapped: ${words[i+1]} <-> ${words[i]}"
        fi
#        echo
    else
        # Случай, когда левое слово должно быть больше
        if [ ${#words[i]} -lt ${#words[i+1]} ]; then
            # Меняем местами эти два слова
            buff_word=${words[i]}
            words[$i]=${words[i+1]}
            words[$i+1]=$buff_word
            unset buff_word
#            echo -n "Swapped: ${words[i+1]} <-> ${words[i]}"
        fi
#        echo
    fi
done

for (( i = 0; i < ${#words[@]}; i++ )); do
    if [ $(( $i % 2 )) == 0 ]; then
        # Случай, когда слово должно быть меньше
        current_word=$( echo "${words[i]}" | tr '[:upper:]' '[:lower:]' )
        echo -n "$current_word"
        unset current_word
    else
        # Случай, когда слово должно быть больше
        current_word=$( echo "${words[i]}" | tr '[:lower:]' '[:upper:]' )
        echo -n "$current_word"
        unset current_word
    fi
    if [ $i != $(( ${#words[@]} - 1 )) ]; then
        echo -n " "
    fi
done

echo # \n
exit 0

#####
#  Task 2
#  Вам дается строка s, состоящая из подстрок s(1), s(2), ..., s(n), разделенных пробелами. Пример: "after be arrived two My so"
#  Задача
#  Возвратить строку t, имеющую следующее свойство:
#  length t(O) <= length t(1) >= length t(2) <= length t(3) >= length t(4) .... (P)
#  где t(i) - это подстрока s; вы должны соблюдать следующее правило:
#  на каждом шаге слева направо вы можете перемещать только либо уже последовательные строки, либо строки, которые стали последовательными после предыдущего перемещения. Количество ходов должно быть минимальным.
#  Давайте продолжим с нашим примером:
#  Длина "after" больше, чем длина "be". Давайте переместим их -> "be after arrived two My so"
#  Длина "after" меньше длины "arrived". Давайте переместим их -> "be arrived after two My so"
#  Длина "after" больше, чем длина "two" -> "be arrived two after My so"
#  Длина "after" больше, чем длина "My". Хорошо! Наконец, длина "My" и "so" одинакова, ничего не поделаешь. В конце процесса подстроки s(i) проверяются:
#  length s(0) <= length s(1) >= length s(2) <= length s(3) >= length (s4) <= length (s5)
#  Следовательно, учитывая строку s подстрок s(i), функция arrange с предыдущим процессом должна возвращать уникальную строку t, имеющую свойство (P).
#  Это что-то вроде американских горок или вверх-вниз. Когда у вас есть свойство (P), чтобы сделать результат более "вверх и вниз" видимым, t (0), t (2), ... будут строчными, а остальные - прописными.
#  arrange("after be arrived two My so") should return "be ARRIVED two AFTER my SO"
#  Записи:
#  Строка "My after be arrived so two" имеет свойство (P), но не может быть получена описанным процессом, поэтому она не будет принята в результате. Свойство (P) само по себе не дает единства.
#  Процесс: двигайтесь слева направо, перемещайте только последовательные строки, когда это необходимо.
#  Для первых фиксированных тестов необходимое количество ходов для получения свойства (P) указывается в качестве комментария, чтобы вы могли знать, следует ли ваш процесс правилу.
#####